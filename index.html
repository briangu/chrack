
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Dimensional Charting</title>
    <link rel="stylesheet" type="text/css" href="http://dc-js.github.io/dc.js/css/dc.css"/>
    <script type="text/javascript" src="http://dc-js.github.io/dc.js/js/d3.js"></script>
    <script type="text/javascript" src="http://dc-js.github.io/dc.js/js/crossfilter.js"></script>
    <script type="text/javascript" src="http://dc-js.github.io/dc.js/js/dc.js"></script>
    <style>
         .heat-box {
           stroke: #E6E6E6;
           stroke-width: 2px;
         }
    </style>
</head>
<body>
  <div id="test"></div>
  <div class=".dc-data-table" id="event-table"></div>

<script>
var maxCount = 0;
var data = {
  0: {
    0: { count: 0, events: [] },
    1: { count: 0, events: [] },
    2: { count: 0, events: [] },
    3: { count: 0, events: [] }
  },
  1: {
    0: { count: 0, events: [] },
    1: { count: 0, events: [] },
    2: { count: 0, events: [] },
    3: { count: 0, events: [] }
  },
  2: {
    0: { count: 0, events: [] },
    1: { count: 0, events: [] },
    2: { count: 0, events: [] },
    3: { count: 0, events: [] }
  },
  3: {
    0: { count: 0, events: [] },
    1: { count: 0, events: [] },
    2: { count: 0, events: [] },
    3: { count: 0, events: [] }
  }
}
var transformCountsToChartData = function() {
  var chartData = [];
  for (var src_node_id in data) {
    for (var dest_node_id in data[src_node_id]) {
      if (!isNaN(src_node_id) && !isNaN(dest_node_id)) {
        var ndxData = {
          key: [src_node_id, dest_node_id],
          count: data[src_node_id][dest_node_id].count
        }
        chartData.push(ndxData);
      }
    }
  }
  return chartData;
}

var ndx       = crossfilter(transformCountsToChartData()),
    runDim    = ndx.dimension(function(d) { return [+d.key[0], +d.key[1]]; }),
    runGroup  = runDim.group().reduceSum(function(d) { return +d.count; });

var heatColorMapping = function(d) {
  return d3.scale.linear().domain([0,maxCount]).range(["lightgray", "red"])(d);
};
heatColorMapping.domain = function() {
  return [0,maxCount];
};

var chart = dc.heatMap("#test");
chart
  .width(45 * 20 + 80)
  .height(45 * 5 + 40)
  .dimension(runDim)
  .group(runGroup)
  .keyAccessor(function(d) { return +d.key[0]; })
  .valueAccessor(function(d) { return +d.key[1]; })
  .colorAccessor(function(d) { return +d.value; })
  .colors(heatColorMapping)
  .calculateColorDomain();
chart.render();

var countDimension = ndx.dimension(function (d) {
    return d.count;
});

var periodicUpdater = function() {
  ndx.add(transformCountsToChartData());
  dc.redrawAll();
}

var connection
window.addEventListener("load", function () {
	connection = new WebSocket("ws://"+window.location.hostname+":8081")
	connection.onopen = function () {
		console.log("Connection opened")
    connection.send("hello")
	}
	connection.onclose = function () {
		console.log("Connection closed")
	}
	connection.onerror = function () {
		console.error("Connection error")
	}
	connection.onmessage = function (event) {
    var clientData = JSON.parse(event.data);
    console.log(clientData);
    Object.keys(clientData.eventData).forEach(function(src_node_id) {
      Object.keys(clientData.eventData[src_node_id]).forEach(function(dest_node_id){
        console.log(src_node_id, " ", dest_node_id);
        var wedge = clientData.eventData[src_node_id][dest_node_id];
        var intersection = data[src_node_id][dest_node_id];
        intersection.count += wedge.count;
        wedge.events.forEach(function(row) {
          intersection.events.push(row);
        });
        if (maxCount < intersection.count) {
          maxCount = intersection.count;
        }
      })
    })
	}

  window.setInterval(periodicUpdater, 2000);
})
</script>
</body>
</html>
